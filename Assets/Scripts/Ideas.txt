Alright so I got the basic idea of the projet down.

Which is to have a center start/stop button 

and Eight Interactable objects that will play sounds 

So I have eight Interactables. I two things to work first

Start and Stop, lets say this project runs at global BPM of 120.

----
I did the math for this a few days ago, theres a way to calculate how often a signal is going to be sent

If i have a global BPM of 120, 
If I wanted Interactable 8 to hit 8 times in the duration of 4 bars,
the note would have to hit every 250ms

A signal would have to be sent every 2000ms for Interactable 1 to hit 1 time in the duration of 4 bars 

Interactable 1 Stats: 2000ms for 1 hit      in the duration of 4 bars 
Interactable 2 Stats: 1750ms for 2 hits
Interactable 3 Stats: 1500ms for 3 hits 
Interactable 4 Stats: 1250ms for 4 hits 
Interactable 5 Stats: 1000ms for 5 hits 
Interactable 6 Stats: 750 ms for 6 hits 
Interactable 7 Stats: 500 ms for 7 hits
Interactable 8 Stats: 250 ms for 8 hits

==========

I can start off with a Start/Stop Script that is responsible for sending out play and pause signals to
the Interactables

What are the requirements for this script?
It needs to have a boolean option to control the start/stop 

How do i make the object Interactable with a pop up to click or press E or something 

Then we check if we can use that to switch the boolean value to on or off

Then we tie that into the Interactable

===================

So I just finished the part where I built the circle of Interactables.
Next is to build an accurate metronome that will allow me to send accurate signals to each Interactable.

    This requires actual DSP knowledge, I gotta find an accurate resource to build this.


=============

It's time to build a relationship between the start/stop button and the interactables 

I know I can GetComponent from different objects and then access public variables
I could probabably access the ticks or the running

For right now, lets just focus on having the interactable read the signal.

NotePlayer is now able to read that the StartStop script is running. 
Now its a matter of reading the metronome's ticks

================

Since I'm not sure I can downright read the Start/Stop scripts ticks the way a mucician would
listen to a metronome, there are other options.
1) Each Interactable has its own metronome that is based off of the StartStop buttons BPM, which 
will be a global variable that any interactable can read if they GetComponent.
2) Try a bit more to get the Interactables to read the metronome

They way a human reads a metronome is by listening to its ticks and tocks. We're always 
listening, but make real notice of the ticks and tocks. 

The thing about this project is that every single Interactable has its own sub-bpm if you will

So what I could do is scrap the current Scripts, Keep the Interactor, 
Have the Metronome simply hold the BPM and the Time Signature 
The NotePlayers will read the BPM, and do some math to decide what subBPM they will play

====================

Let me see if I can reiterate this part 

if we have a bpm of 120
beatDuration = 60s / BPM 
The duration of beat is .5 seconds 
.250  = (60 / 120) / 2           | this is an eigth note if I divied by 2 that would be a 16th note
.5    = (60 / 120)               | this is a quarter note 
.750  = ((60 / 120) / 2) * 3)    | this is a dotted triplet (?) maybe
.1000 = (60 / 120) * 2           | this is this is a half note 
.1250 = (60 / 120 / 2) * 5       | this is a fifth note ???? i don't know 

So the pattern looks like: 60s / bpm is the base 
and then we divide by 2 and add adjustments by multplying by a number 

==========

LETS GOOOOOOOOOOO I GOT EVERYTHING PLAYING SOMETHING

Tomorrow I gotta make sure I can turn off and off each interactable

At some point I gotta start adding visual queues to make sure that its easy to 
tell when something is on or off

==========

Alright so I've got to a point where I have each interactable playing a note as a certain interval,
described in ms

So the 1/4 note is played at .5 m milliseconds, and all the other interactables follow suite 

Now its note exactly a polrhyhtm generator. 
But it is sort of a sequencer
It's still pretty fun to use, I think its a matter of two things at this point 

1) What direction do i want to take this in?
    Is it going to continue being a polrhyhtm generator or 
    am I just going to have a sequencer?
    If its going to be a sequencer, doesn't it make more sense to have the 
    pattern of interactables placed in a different order?

    I have time to decide but i need to decide soon

2) How is this project going to look?? 



=================
So the next objective is to create a system of popup menus that will help me adjust 
the parameters of the interactable within the game, rather than having to exit the game 
or going into the unity developr options to make those changes 

I have to look more into the canvas system in unity
If I go to the library tomorrow I can make it a point to check that out


I havea small prototype of the UI going right now
It looks how I imagined it in my head, but it's time to nail down the functionality of the product
The interactable has two functions as of right now 
    1) its rhyhtm 
    2) on and off 

I'm considering adding a 3rd
    3) its volume 

But that may be for a bit later 

I have the prototype setup,
The thing I don't know now is how 
to get the player to interact with the UI and have the UI react
I can't use the same method as the other interactor, as that sends a raycast in the direction of the interactable
Now sure how accurate it is, and there isn't really a way for me to tell either 

That might be a problem for tomorrow

https://www.youtube.com/watch?v=ccqiNWsYJnI

https://forum.unity.com/threads/efficient-method-to-create-reticle.344248/


==================

As of right now the interactor is handling the OnOff.
I have a canvas that has a button that is labeled OnOff

======
I'm going to try creating a new script, placing it on the canvas, having the button call the onClick script, 
and allowing the script access to the interactable NotePlayer object,

So clicking the button will activate or deactivate the NotePlayer bool to turn it off and on

The thing with the tutorials that i've seen, they're all in 2D.
My project is 3d, and the Canvas is present in the world, not on 2d screen.
--
From my research online, there really isn't a solution for what I want to do, aside from raycast,
but the thing is that My UI isn't really an object, at least not in the same way as 
my other in game objects are, such as the interactable NotePlayer. I can use raycast on that, 
because casting the ray actually hits something 

So I have two options here, I can recreate the UI purely using game objects, and apply some sort of 
canvas ON TOP of that so that theres still text and such, or I can continue down this path of 
making a Canvas UI interactable.

I can't really find any resources on what I want to do with the UI. That kind of sucks, 
so I either spend a lot of time engineering a solution, or try out the other option of making a bunch
of objects that can be interacted with 

That pathway also has its difficulties, which are probably going to come along with the 
dropdown idea that I had and the volume mod

The third option is to have a popup UI that I can mess around with, 
Instead of having an E press Raycast to the NotePlayer to turn off and on, 
I can have E press raycast to open up a UI that I can interact with my mouse 


I'm kind of stuck here, 
If I create a cube, with scale (1,1,1), the system I have to interact with objects through raycasting, works
But the moment I change the scale to something more abstract like a thin rectangular prism, the interact system 
only works on a really weird condition.
I have to jump and create friction with the object, slide down to as low as it'll let me be without touching
the ground, and spam E. Thats the only condition that i've found that works.

So the potential solution of creating game objects to simulate the UI Canvas has its own issue.
I mean, I could make large objects and put names or something on them so that the interact system actually
works, but it wouldn't look pretty and I wouldn't be happy with its presentation.

The other potential solution is to scale everything to be very big.

The thing with the UI is that I scaled the UI to be at 0.01 of the canvas
So that is potentially the issue with raycasting not working.

==
I think i'm going to try using the UI tool kit, project the UI onto a texture in the world space
and then try to raycast to interact with the UI

I've figured out something about the way I'm raycasting
I need to raycast in the direction that the camera is facing, at the reticle 

The way things are right now, it raycasts just directly forward with no indication or tilt or rotation 
The next objective is to make Interactor.cs sending out a raycast using the cameras reticle, 
Instead of from the players main position

I feel like once i get an understanding of how the raycasts work, I can make sure that they 
come directly out of the camera and then move onto integrating the UI

If the reason that the UI was never detecting the raycast was because of the forward direction 
it was coming out of the player, then we can resolve that by having it come out of the camera 

== 

After a little bit of research, I got the camera raycast working.
I had to set the player camera tag as MainCamera, then I could use use Camera.main in
the Interactor.cs script.

Then from there, using the camera position to generate a raycast

The UI button works now, and I can also interact with the NotePlayer. 
Now its just a matter of having the I/O button turn the NotePlayer on and off, which should be a bit easier
than working out the UI.

After the I/O button I can probably figure out the dropdown, then the volume 

-- Dub I got the I/O button to turn the NotePlayer on and off while the metronome is playing
Next up is the drop menu. We'll see how that goes lol 

==========

Today, I'm going to try and implement the dropdown, maybe see how far I can go too

Right Now, I added a box collider to the dropdown to try and get it to notice raycasts.
Without the box collider, hitting the dropdown with a raycast does not do anything. 

Still, the dropdown menu doesn't activate.
I'm starting to think though, given that there are 1/16 options for the menu, 
is a dropdown the best, most user friendly and intuitive approach

Even if i did get it to activate, the fact that It would then drop down 16 items, might clip 
into the floor or cover up other items 

Two things come to mind 
    [<] Text [>]
        where there are to buttons on the left and right that manipulate the rhyhtm of the 
        NotePlayer, and Text being the place where it will display changes 

Or 
    having a circle with different patterns to select 
    Selecting a different pattern will gray it, and whiten all others to claim that it is 
    selected 
            2
         5     3
            4

    So something like a dail. If two is selected, it wil be grayed out and the others will be 
    lighter, to indicate that it was selected 
    But then again, there are going to be 16 options 

    Now, the other option is to make a board 
    1   2  3  4 
    5   6  7  8
    9  10 11 12
    13 14 15 16 
        or 
    1  2  3  4  5  6  7  8
    9 10 11 12 13 14 15 16

    This would be similar to the dail in selection, but might be more viable for space 

    I think the first option is definitely easier to implement, but in terms of 
    freedom, a little bit more limited 
    Since you would have to click through so many time to get different rhyhtms 

    I think all options are better than the dropdown as initially presented

    So, i can either start with a test canvas for the Grid presentation 
    or get started on implementing two buttons and text box

    -- 
    I think that the grid is definitely the better choice
    Start by making two buttons, 4/16 and 6/16 

    and then testing to see if they change anything.
    I also need to think about how the sciprt is going to work. How am I gonna set it up
    so that the grid is sort of, one unit, and eat button inside of it does something 

    Can i put a script a canvas and use it to access buttons?
    
==============

So Today I've reworked the UI and the grid a little bit, all the buttons in the grid work
I've not yet started on the Volume, 
So I have 2 of the 3 UI buttons working
I just realized that I have to add a fourth one -> a way for the player to input the 
BPM 

====
https://forum.unity.com/threads/how-can-i-manipulate-a-2d-slider-using-my-mouse-in-3d-world-space.1318095/

This is a link to someone that was working on pretty much exactly the problem that I have
What they did is put a collider on top of the slider, and then the user raycasts onto the collider 

We take an X Y or Z value from the hitInfo, and apply that to the slider values after being normalized 
to a value that the slider understands

I've created the collider, and now I want to output the hitInfo onto console

The issue than I'm encountering right now is that the Interact() function doesn't take in 
any variables and it doesn't actually have access to the hitInfo
Since the raycast comes from Interactor.cs

So i have a few option here 
1) pass a float into interact 
    i know ill have issues with this since my other scripts don't have any variables passing into it 
2) Check the tag, 
    if (tagged slider) call Interact(with float) 
    else call the regular Interact() function 
3) Change the variable in Slider from the Interactor.cs script, but his might have the same issues 
    as the first option, since we still need to differentiate between the slider and the buttons 

I think the best course of action is option number 2, we let the Slider Script handle changing 
the variables of the slider 

All the Interactor is supposed to do is raycast and hit detection
Maybe we can pass the hitInfo into the SliderScript

if(Physics.Raycast(r, out RaycastHit hitInfo, InteractRange)) {
                if(hitInfo.collider.CompareTag("Slider")){
                    if(hitInfo.collider.gameObject.TryGetComponent<SliderScript>(out SliderScript sScript)) {
                        sScript.passHitInfo(hitInfo.point.y);
                    }
                } else (hitInfo.collider.gameObject.TryGetComponent(out IInteractable interactObj)) {
                    interactObj.Interact();
                }
            }

if(Physics.Raycast(r, out RaycastHit hitInfo, InteractRange)) {
    if(hitInfo.collider.gameObject.TryGetComponent(out IInteractable interactObj)) {
        Debug.Log(hitInfo.point);
        interactObj.Interact();
    }
}

============

Now I finishsed the UI, to the best of my ability.
Now I'm not entirely sure what to do with the project.

How do I further develop it?

I think, in the best case scenario, it would be a bit of a sandbox kind of thing 
Where you can place speakers with certain sounds and create a 3d space where you can make your own beats

I think the next on the list is to be able to freely modify the BPM and press an 
actuall start/stop button 

Maybe this part of the UI should always face the player 

